---
phase: 05-supabase-foundation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - supabase/migrations/00001_create_contacts_and_book_requests.sql
  - middleware.ts
autonomous: false
user_setup:
  - service: supabase
    why: "Database and authentication backend"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon public key"
    account_setup:
      - task: "Create Supabase account and project"
        steps: "Go to supabase.com -> New Project -> Region: US West -> Free tier"
  - service: resend
    why: "Production email delivery via custom SMTP"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
    account_setup:
      - task: "Create Resend account"
        steps: "Go to resend.com -> Sign up"
      - task: "Add and verify custom domain"
        steps: "Resend Dashboard -> Domains -> Add Domain -> Add DNS records (SPF, DKIM, DMARC) -> Wait for verification (can take 24-48h)"
    dashboard_config:
      - task: "Configure custom domain DNS records"
        location: "Your domain registrar's DNS settings"

must_haves:
  truths:
    - "Database tables (contacts, book_requests) exist in Supabase with Row Level Security enabled"
    - "RLS policies restrict anonymous inserts to contacts and book_requests only (no reads, updates, or deletes)"
    - "Middleware refreshes JWT session on every non-static request"
    - "Existing static routes remain static after middleware addition"
    - "Production email delivery is configured via Resend with custom domain"
  artifacts:
    - path: "supabase/migrations/00001_create_contacts_and_book_requests.sql"
      provides: "SQL migration creating contacts and book_requests tables with RLS policies and indexes"
      contains: "CREATE TABLE"
    - path: "middleware.ts"
      provides: "Next.js middleware that refreshes Supabase JWT session on every request"
      contains: "updateSession"
  key_links:
    - from: "middleware.ts"
      to: "src/lib/supabase/middleware.ts"
      via: "import updateSession"
      pattern: "import.*updateSession.*from.*@/lib/supabase/middleware"
    - from: "middleware.ts"
      to: "Next.js request pipeline"
      via: "matcher config excluding static assets"
      pattern: "export const config"
    - from: "supabase/migrations/00001_create_contacts_and_book_requests.sql"
      to: "Supabase database"
      via: "SQL execution in Supabase SQL Editor"
      pattern: "CREATE TABLE"
---

<objective>
Create the database migration SQL for contacts and book_requests tables with Row Level Security, implement Next.js middleware for JWT session refresh, and guide the user through Supabase/Resend account setup.

Purpose: Complete the backend infrastructure so phases 6-8 can write to the database and send emails. The migration defines the shared data model (one contact record serves both notification signup and Book request flows per user decision). The middleware ensures JWT tokens are refreshed on every request.

Output: SQL migration file ready to execute, root middleware.ts, and verified Supabase + Resend connectivity.
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-supabase-foundation/05-RESEARCH.md
@.planning/phases/05-supabase-foundation/05-01-SUMMARY.md
@src/lib/supabase/middleware.ts
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration SQL and Next.js middleware</name>
  <files>
    supabase/migrations/00001_create_contacts_and_book_requests.sql
    middleware.ts
  </files>
  <action>
Create `supabase/migrations/00001_create_contacts_and_book_requests.sql`:

This is the shared data model per user decision — one email record serves both notification signup and Book request flows.

```sql
-- Contacts table: shared record for notification signups and Book requesters
CREATE TABLE public.contacts (
  id BIGSERIAL PRIMARY KEY,
  email TEXT NOT NULL,
  name TEXT NOT NULL,
  signed_up_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  email_verified BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Case-insensitive unique constraint on email
CREATE UNIQUE INDEX idx_contacts_email_unique ON public.contacts (LOWER(email));

-- Index for email lookups (used by RLS policies and application queries)
CREATE INDEX idx_contacts_email_lower ON public.contacts (LOWER(email));

-- Book requests table: tracks which Book type was requested
CREATE TABLE public.book_requests (
  id BIGSERIAL PRIMARY KEY,
  contact_id BIGINT NOT NULL REFERENCES public.contacts(id) ON DELETE CASCADE,
  book_type TEXT NOT NULL CHECK (book_type IN ('publishers', 'agents', 'therapists')),
  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index for lookups by contact
CREATE INDEX idx_book_requests_contact_id ON public.book_requests (contact_id);

-- Enable Row Level Security on both tables
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.book_requests ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Allow anonymous inserts only (phases 6-8 will use service role for reads/updates)
-- Anonymous users can submit their contact info (notification signup)
CREATE POLICY "Allow anonymous insert on contacts"
  ON public.contacts
  FOR INSERT
  TO anon
  WITH CHECK (true);

-- Anonymous users can submit Book requests
CREATE POLICY "Allow anonymous insert on book_requests"
  ON public.book_requests
  FOR INSERT
  TO anon
  WITH CHECK (true);

-- Note: No SELECT/UPDATE/DELETE policies for anon role.
-- Server-side operations (email verification, PDF download auth) will use
-- the service_role key which bypasses RLS entirely.
-- If authenticated user policies are needed later, add them in a future migration.
```

Design decisions (Claude's discretion per CONTEXT.md):
- BIGSERIAL for IDs (simple, sufficient for pre-launch scale)
- Case-insensitive email uniqueness via functional index on LOWER(email)
- email_verified is boolean (not timestamped) per user decision
- signed_up_at tracks signup date per user decision
- book_type uses CHECK constraint to restrict to valid values
- ON DELETE CASCADE on book_requests.contact_id for data integrity
- RLS allows anon INSERT only — reads/updates will use service_role in Server Actions
- No updated_at trigger (add if needed later; simple for now)

Create `middleware.ts` at project root (NOT src/middleware.ts — Next.js requires it at root or src root):

```typescript
import { updateSession } from "@/lib/supabase/middleware";
import { type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization)
     * - favicon.ico (favicon)
     * - Static assets (svg, png, jpg, jpeg, gif, webp)
     *
     * This ensures JWT refresh runs on page navigations and API routes
     * but not on static asset requests.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

IMPORTANT — Static route preservation:
- The middleware only refreshes cookies, it does NOT redirect or block any routes
- Since middleware runs at the Edge, `@supabase/ssr` createServerClient is designed for this context
- The matcher explicitly excludes static assets
- Existing pages (/, /who, /what) will still be statically generated — middleware runs at request time, not build time, so static generation is unaffected

After creating both files, run `npm run build` to verify:
1. No TypeScript errors from middleware.ts
2. All existing routes still build as static
3. The middleware.ts is detected by Next.js (check build output for "Middleware" line)
  </action>
  <verify>
Run `npm run build` — must succeed. Check build output for:
- "Middleware" listed in the build output (confirms Next.js detected it)
- Routes /, /who, /what still show as static (circle icon, not lambda)
Run `npx tsc --noEmit` — must pass.
Confirm files exist: `ls middleware.ts supabase/migrations/`
  </verify>
  <done>
middleware.ts exists at project root, imports updateSession from src/lib/supabase/middleware.ts, and has a matcher that excludes static assets. SQL migration file exists with contacts and book_requests tables, RLS enabled, anon INSERT policies, and appropriate indexes. Build passes with all existing routes remaining static.
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: User creates Supabase and Resend accounts, configures environment</name>
  <action>
The user must create external accounts and configure secrets that Claude cannot access.
  </action>
  <instructions>
**Step 1: Create Supabase project**
1. Go to https://supabase.com and create an account (or sign in)
2. Click "New Project"
3. Choose organization (create one if needed)
4. Project name: `continua` (or your preference)
5. Database password: generate a strong one and save it
6. Region: **US West** (per decision)
7. Plan: **Free** (per decision — upgrade to Pro before launch to avoid 1-week inactivity pausing)
8. Click "Create new project" and wait for provisioning (~2 minutes)

**Step 2: Get Supabase API credentials**
1. In your Supabase project dashboard, go to **Project Settings** (gear icon) -> **API**
2. Copy **Project URL** (looks like `https://abcdefg.supabase.co`)
3. Copy **anon public** key (under "Project API keys")

**Step 3: Run the database migration**
1. In your Supabase dashboard, go to **SQL Editor**
2. Click "New query"
3. Paste the contents of `supabase/migrations/00001_create_contacts_and_book_requests.sql`
4. Click "Run" — should show "Success. No rows returned"
5. Verify in **Table Editor**: you should see `contacts` and `book_requests` tables
6. Verify RLS: click on each table -> "RLS" tab should show "RLS enabled" with the INSERT policy

**Step 4: Create Resend account**
1. Go to https://resend.com and create an account
2. Go to **API Keys** -> **Create API Key**
3. Copy the API key (starts with `re_`)

**Step 5: Add custom domain to Resend**
1. In Resend dashboard, go to **Domains** -> **Add Domain**
2. Enter your sending domain
3. Add the DNS records Resend provides (SPF, DKIM, DMARC) at your domain registrar
4. Wait for DNS verification (can take 24-48 hours)
5. Once verified, your sender address `noreply@yourdomain.com` will work

**Step 6: Configure local environment**
1. Copy the template: `cp .env.local.example .env.local`
2. Fill in real values:
   - `NEXT_PUBLIC_SUPABASE_URL` = Project URL from Step 2
   - `NEXT_PUBLIC_SUPABASE_ANON_KEY` = anon key from Step 2
   - `RESEND_API_KEY` = API key from Step 4
   - `RESEND_FROM_EMAIL` = `noreply@yourdomain.com`
3. Verify the dev server starts: `npm run dev`

**Step 7: Configure Vercel environment variables**
1. In Vercel dashboard -> your project -> Settings -> Environment Variables
2. Add all 4 variables for both Preview and Production environments
3. Redeploy to pick up the new variables

**After completing all steps, type "done" to continue.**
  </instructions>
  <resume-signal>Type "done" when all accounts are created, migration is run, and environment variables are configured in .env.local and Vercel.</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes with middleware detected in build output
2. All existing routes (/, /who, /what) remain static
3. `supabase/migrations/00001_create_contacts_and_book_requests.sql` contains CREATE TABLE for contacts and book_requests
4. RLS is enabled on both tables with anon INSERT policies
5. `middleware.ts` imports updateSession and has correct matcher
6. User confirms Supabase tables exist with RLS enabled
7. User confirms Resend API key works
8. User confirms .env.local is configured and dev server starts
</verification>

<success_criteria>
- Database tables (contacts, book_requests) exist in Supabase with RLS enabled and anon INSERT policies
- Middleware refreshes JWT session on every non-static request
- All existing static routes build without errors
- Resend account exists with custom domain (may still be verifying DNS)
- Environment variables configured for local dev (.env.local) and Vercel
- Phase 6 can immediately start building the notification signup form
</success_criteria>

<output>
After completion, create `.planning/phases/05-supabase-foundation/05-02-SUMMARY.md`
</output>
