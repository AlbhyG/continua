---
phase: 06-notification-signup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/validations/signup.ts
  - src/app/actions/signup.ts
  - supabase/migrations/00002_add_contacts_update_policy.sql
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - "Server Action validates name and email with Zod before database write"
    - "Duplicate email submissions succeed silently via upsert (privacy-safe)"
    - "RLS allows upsert (INSERT + UPDATE) for anonymous role on contacts table"
  artifacts:
    - path: "src/lib/validations/signup.ts"
      provides: "Shared Zod schema for signup validation"
      contains: "signupSchema"
    - path: "src/app/actions/signup.ts"
      provides: "Server Action for signup form submission"
      exports: ["signupAction"]
    - path: "supabase/migrations/00002_add_contacts_update_policy.sql"
      provides: "RLS UPDATE policy for contacts upsert"
      contains: "CREATE POLICY"
  key_links:
    - from: "src/app/actions/signup.ts"
      to: "src/lib/validations/signup.ts"
      via: "import signupSchema"
      pattern: "import.*signupSchema.*from.*validations/signup"
    - from: "src/app/actions/signup.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient for database access"
      pattern: "createClient.*from.*supabase/server"
    - from: "src/app/actions/signup.ts"
      to: "supabase contacts table"
      via: "upsert with onConflict"
      pattern: "\\.upsert\\("
---

<objective>
Create the server-side foundation for notification signup: install Zod, define the shared validation schema, implement the Server Action that validates and persists signup data, and add the RLS policy needed for upsert.

Purpose: Establishes the backend plumbing that Plan 02's UI will submit to. Separating server logic from UI keeps each plan focused and within context budget.

Output: Working Server Action that accepts FormData, validates with Zod, upserts to contacts table, and returns typed state for the client.
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-notification-signup/06-RESEARCH.md
@.planning/phases/05-supabase-foundation/05-02-SUMMARY.md

# Key codebase references
@src/lib/supabase/server.ts
@supabase/migrations/00001_create_contacts_and_book_requests.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod and create shared validation schema</name>
  <files>
    package.json
    package-lock.json
    src/lib/validations/signup.ts
  </files>
  <action>
1. Install Zod:
   ```bash
   npm install zod
   ```

2. Create `src/lib/validations/signup.ts` with a shared Zod schema used by both the Server Action (server-side validation) and the client component (client-side on-blur validation):

   ```typescript
   import { z } from 'zod'

   export const signupSchema = z.object({
     name: z
       .string()
       .min(1, 'Name is required')
       .max(100, 'Name must be 100 characters or less'),
     email: z
       .string()
       .min(1, 'Email is required')
       .email('Please enter a valid email address')
       .transform((e) => e.trim().toLowerCase()),
   })

   export type SignupInput = z.infer<typeof signupSchema>
   ```

   The schema:
   - Validates name is non-empty and under 100 chars
   - Validates email format using Zod's built-in `.email()` (not custom regex)
   - Transforms email to trimmed lowercase (matches LOWER(email) database index)
   - Exports `SignupInput` type for use in Server Action
  </action>
  <verify>
    - `npm ls zod` shows zod installed
    - `npx tsc --noEmit` passes with no errors
    - `src/lib/validations/signup.ts` exists and exports signupSchema and SignupInput
  </verify>
  <done>Zod installed, shared validation schema exports signupSchema with name/email validation and email lowercase transform</done>
</task>

<task type="auto">
  <name>Task 2: Create Server Action and RLS migration for signup upsert</name>
  <files>
    src/app/actions/signup.ts
    supabase/migrations/00002_add_contacts_update_policy.sql
  </files>
  <action>
1. Create `src/app/actions/signup.ts` — the Server Action for form submission:

   ```typescript
   'use server'

   import { signupSchema } from '@/lib/validations/signup'
   import { createClient } from '@/lib/supabase/server'

   export type SignupState = {
     errors?: {
       name?: string[]
       email?: string[]
       form?: string[]
     }
     success?: boolean
   } | null

   export async function signupAction(
     prevState: SignupState,
     formData: FormData
   ): Promise<SignupState> {
     const validatedFields = signupSchema.safeParse({
       name: formData.get('name'),
       email: formData.get('email'),
     })

     if (!validatedFields.success) {
       return {
         errors: validatedFields.error.flatten().fieldErrors,
       }
     }

     const { name, email } = validatedFields.data

     try {
       const supabase = await createClient()
       const { error } = await supabase
         .from('contacts')
         .upsert(
           {
             email,
             name,
             signed_up_at: new Date().toISOString(),
           },
           { onConflict: 'email' }
         )

       if (error) {
         console.error('Signup database error:', error)
         return {
           errors: { form: ['Something went wrong. Please try again.'] },
         }
       }

       return { success: true }
     } catch (err) {
       console.error('Signup unexpected error:', err)
       return {
         errors: { form: ['Something went wrong. Please try again.'] },
       }
     }
   }
   ```

   Key decisions:
   - Uses `signupSchema` from shared validation (DRY with client)
   - Email already lowercased by Zod transform (matches LOWER(email) index)
   - Upsert with `onConflict: 'email'` handles duplicates silently — same success response whether new or existing email (privacy-safe per user decision)
   - Generic error messages only — never reveals whether email exists
   - `SignupState` type exported for use by `useActionState` in Plan 02

2. Create `supabase/migrations/00002_add_contacts_update_policy.sql`:

   **CRITICAL:** The existing RLS only allows INSERT for anon role. Supabase upsert requires both INSERT and UPDATE permissions. Without this policy, upsert will fail on duplicate emails.

   ```sql
   -- Add UPDATE policy for contacts table to support upsert (INSERT + UPDATE)
   -- Required because Supabase upsert with onConflict needs UPDATE permission
   -- when a matching record exists.
   CREATE POLICY "Allow anonymous update on contacts for upsert"
     ON public.contacts
     FOR UPDATE
     TO anon
     USING (true)
     WITH CHECK (true);
   ```

   After creating the migration file, deploy it:
   ```bash
   npx supabase db push
   ```

   If `supabase db push` fails due to auth, the executor should note the SQL and let the user apply it manually via the Supabase Dashboard SQL Editor as a fallback. The migration file should still be committed for version control regardless.
  </action>
  <verify>
    - `npx tsc --noEmit` passes (Server Action compiles)
    - `npm run build` succeeds (Server Action is valid server module)
    - `supabase/migrations/00002_add_contacts_update_policy.sql` exists
    - Migration deployed (or documented for manual application)
  </verify>
  <done>Server Action validates with Zod, upserts to contacts table with duplicate handling, returns typed SignupState. RLS UPDATE policy added to support upsert for anon role.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes — Server Action compiles, no TypeScript errors
2. All existing routes (/, /who, /what) still generate as static pages (Server Action doesn't force dynamic)
3. `src/lib/validations/signup.ts` exports signupSchema
4. `src/app/actions/signup.ts` exports signupAction and SignupState type
5. RLS migration file exists at `supabase/migrations/00002_add_contacts_update_policy.sql`
</verification>

<success_criteria>
- Zod installed and validation schema defines name + email rules with email lowercase transform
- Server Action accepts FormData, validates with Zod, upserts to contacts table
- Duplicate emails handled via upsert (same success response, privacy-safe)
- Generic error messages only (no email existence leakage)
- SignupState type exported for client consumption
- RLS UPDATE policy enables upsert for anonymous role
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-notification-signup/06-01-SUMMARY.md`
</output>
