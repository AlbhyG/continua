---
phase: 07-email-verification-flow
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/app/actions/request-verification.ts
  - src/app/actions/verify-email.ts
  - src/app/verify/[token]/page.tsx
  - src/app/verify/[token]/verification-form.tsx
autonomous: false

must_haves:
  truths:
    - "User receives branded verification email after requesting Book download from a dialog"
    - "User clicking verification link in email lands on confirmation page with Verify button"
    - "User clicking Verify button on confirmation page completes verification and sees success message"
    - "User with expired verification link sees clear error message with guidance to re-request"
    - "User with invalid/malformed verification link sees error message"
    - "Verification tokens survive email link prefetching because verification requires explicit button click (POST), not page load (GET)"
  artifacts:
    - path: "src/app/actions/request-verification.ts"
      provides: "Server Action to generate token, store in DB, send verification email"
      exports: ["requestVerificationAction", "RequestVerificationState"]
    - path: "src/app/actions/verify-email.ts"
      provides: "Server Action to validate token, mark email verified, clear token"
      exports: ["verifyEmailAction"]
    - path: "src/app/verify/[token]/page.tsx"
      provides: "Two-step verification page that validates token format on load"
      exports: ["default"]
    - path: "src/app/verify/[token]/verification-form.tsx"
      provides: "Client component with Verify Email button that calls verifyEmailAction"
      exports: ["default"]
  key_links:
    - from: "src/app/verify/[token]/verification-form.tsx"
      to: "src/app/actions/verify-email.ts"
      via: "useActionState hook bound to form action"
      pattern: "useActionState.*verifyEmailAction"
    - from: "src/app/actions/request-verification.ts"
      to: "src/lib/tokens/generate.ts"
      via: "import generateVerificationToken"
      pattern: "import.*generateVerificationToken.*from.*@/lib/tokens/generate"
    - from: "src/app/actions/request-verification.ts"
      to: "src/lib/email/send-verification.ts"
      via: "import sendVerificationEmail"
      pattern: "import.*sendVerificationEmail.*from.*@/lib/email/send-verification"
    - from: "src/app/verify/[token]/page.tsx"
      to: "src/app/verify/[token]/verification-form.tsx"
      via: "renders VerificationForm with token prop"
      pattern: "<VerificationForm.*token="
---

<objective>
Build the verification Server Actions and two-step verification page. Wire a Book dialog to trigger verification request.

Purpose: Complete the user-facing email verification flow — from requesting a Book download to confirming email ownership.
Output: Two Server Actions (request + verify), verification page with confirmation button, Book dialog wiring.
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-email-verification-flow/07-RESEARCH.md
@.planning/phases/07-email-verification-flow/07-01-SUMMARY.md
@.planning/phases/06-notification-signup/06-01-SUMMARY.md
@.planning/phases/06-notification-signup/06-02-SUMMARY.md
@src/app/actions/signup.ts
@src/lib/supabase/server.ts
@src/lib/validations/signup.ts
@src/components/dialogs/PublishersDialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create request-verification and verify-email Server Actions</name>
  <files>
    src/app/actions/request-verification.ts
    src/app/actions/verify-email.ts
  </files>
  <action>
    **Request verification action** (`src/app/actions/request-verification.ts`):

    Create `requestVerificationAction` Server Action for use with `useActionState`. This action is called when a user submits their email from a Book dialog to request a download.

    Export `RequestVerificationState` type:
    ```typescript
    export type RequestVerificationState = {
      errors?: { name?: string[]; email?: string[]; form?: string[] }
      success?: boolean
    } | null
    ```

    Signature: `async function requestVerificationAction(prevState: RequestVerificationState, formData: FormData): Promise<RequestVerificationState>`

    Implementation:
    1. Extract and validate `name`, `email`, and `book_type` from FormData using Zod:
       - `name`: string, 1-100 chars (reuse pattern from signupSchema)
       - `email`: valid email, trimmed, lowercased
       - `book_type`: enum of 'publishers' | 'agents' | 'therapists'
    2. Create Supabase server client
    3. Check if contact already exists (SELECT by email):
       - If exists and already verified: return success (they can proceed to download in Phase 8)
       - If exists and not verified: generate new token, update existing record
       - If not exists: insert new contact with token
    4. Generate verification token via `generateVerificationToken()` from `@/lib/tokens/generate`
    5. Set token expiry to `new Date(Date.now() + 24 * 60 * 60 * 1000)` (24 hours from now)
    6. Store token and expiry in contacts table (INSERT or UPDATE depending on step 3)
    7. Insert book_request record (contact_id + book_type) — use INSERT, ignore duplicate
    8. Send verification email via `sendVerificationEmail()` from `@/lib/email/send-verification`
    9. Return `{ success: true }` — always same response whether new or existing (privacy-safe)
    10. On error, return `{ errors: { form: ['Something went wrong. Please try again.'] } }`

    Important: For the SELECT query in step 3, use the anon client (the RLS SELECT policy from Plan 01 allows reads when verification_token IS NOT NULL). But for contacts that are verified (token is NULL), the SELECT will return nothing. Handle this by attempting INSERT first, catching unique violation (23505), then doing UPDATE if duplicate exists. This matches the pattern established in Phase 6 signup action.

    Revised approach (simpler, matches Phase 6 pattern):
    1. Validate inputs
    2. Generate token + expiry
    3. Try INSERT into contacts with email, name, verification_token, verification_token_expires_at
    4. If unique violation (23505): UPDATE existing contact's verification_token and verification_token_expires_at
    5. Get the contact's id (from insert result or via a follow-up query after update)
    6. INSERT into book_requests (contact_id, book_type) — catch duplicate silently
    7. Send verification email
    8. Return success

    For the UPDATE in step 4, since anon has UPDATE policy (from migration 00002), update WHERE email = the email value. To get the contact id after update, include `.select('id')` on the update call.

    **Verify email action** (`src/app/actions/verify-email.ts`):

    Create `verifyEmailAction` for use with `useActionState` on the verification page.

    Signature: `async function verifyEmailAction(prevState: any, formData: FormData)`

    Return type: `{ success?: boolean; error?: string } | null`

    Implementation:
    1. Extract `token` from FormData
    2. Validate token format using `isValidTokenFormat()` from `@/lib/tokens/generate`
    3. Create Supabase server client
    4. Query contacts WHERE `verification_token` = token (RLS SELECT policy allows this since token is not null)
    5. If no result: return `{ error: 'This verification link is invalid or has already been used. Please request a new Book download to receive a fresh link.' }`
    6. Check `verification_token_expires_at < NOW()`:
       - If expired: return `{ error: 'This verification link has expired. Please request a new Book download to receive a fresh link.' }`
    7. UPDATE contact: set `email_verified = true`, `verification_token = null`, `verification_token_expires_at = null`
    8. Return `{ success: true }`
    9. Wrap in try/catch, return generic error on unexpected failures
  </action>
  <verify>
    - `npx tsc --noEmit` passes (both actions compile)
    - `npm run build` succeeds
    - Both actions export their types and functions
  </verify>
  <done>
    request-verification action generates token, stores in DB, sends email, handles duplicates. verify-email action validates token, checks expiry, marks verified, clears token. Both have proper error handling and privacy-safe responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create verification page with two-step flow and update Book dialog</name>
  <files>
    src/app/verify/[token]/page.tsx
    src/app/verify/[token]/verification-form.tsx
    src/components/dialogs/PublishersDialog.tsx
  </files>
  <action>
    **Verification page** (`src/app/verify/[token]/page.tsx`):

    Server Component that validates token format on load (does NOT consume the token).

    Implementation:
    1. Accept `params: Promise<{ token: string }>` (Next.js 15 async params)
    2. Await params to get token
    3. Validate token format using `isValidTokenFormat()` from `@/lib/tokens/generate`
    4. If invalid format: render error state with heading "Invalid Link" and message "This verification link is not valid. Please check the link in your email or request a new Book download."
    5. If valid format: render `<VerificationForm token={token} />`
    6. Page styling: use the site's existing gradient background and glassmorphic card pattern (bg-white/95, backdrop-blur, rounded-2xl, shadow). Center the card vertically and horizontally (min-h-screen, flex, items-center, justify-center).
    7. Add Next.js metadata export: `title: "Verify Email — Continua"`, `description: "Confirm your email address to download your Book."`

    **Verification form** (`src/app/verify/[token]/verification-form.tsx`):

    Client Component ('use client') with confirmation button.

    Props: `{ token: string }`

    Implementation:
    1. Use `useActionState(verifyEmailAction, null)` from React 19
    2. Three states to render:
       a. **Default/pending**: Show heading "Confirm Your Email", body text "Click the button below to verify your email address and access your Book download.", and a "Verify Email" submit button (purple, pill shape, matching site's accent color). Include `<input type="hidden" name="token" value={token} />`.
       b. **Success** (state?.success): Show heading "Email Verified!" with green checkmark styling, body text "Your email has been verified successfully. You'll be able to download your Book shortly." Use the same glassmorphic card styling.
       c. **Error** (state?.error): Show the error message in a red alert box (`role="alert"`) above the submit button. Keep the button visible so user can retry (unless it's an invalid/expired token, in which case the error message includes guidance to re-request).
    3. Button shows "Verifying..." and is disabled when `isPending` is true.
    4. Style the card consistently with the verification page's glassmorphic pattern.

    **Update PublishersDialog** (`src/components/dialogs/PublishersDialog.tsx`):

    Modify the Publishers Book dialog to collect email + name and trigger verification. This serves as the proof-of-concept for the Book download verification flow (Agents and Therapists dialogs will be updated in Phase 8).

    Read the existing PublishersDialog.tsx first to understand its current structure, then:
    1. Add a form view to the dialog (alongside existing content) with name and email fields
    2. Use `useActionState(requestVerificationAction, null)` to handle form submission
    3. Reuse the validation pattern from SignupDialog (signupSchema for client-side validation, blur + change validation)
    4. Add a hidden `book_type` field with value "publishers"
    5. On success: show "Check your email" confirmation (similar to SignupDialog success view)
    6. Keep existing dialog content/description intact — add form below the description text

    Match the form styling to the existing SignupDialog patterns (input styles, error styles, button styles) for visual consistency.
  </action>
  <verify>
    - `npm run build` succeeds
    - `/verify/test-token` route exists in build output
    - PublishersDialog includes form with name, email, and book_type fields
    - VerificationForm uses useActionState with verifyEmailAction
  </verify>
  <done>
    Verification page renders glassmorphic card with token format validation. VerificationForm shows confirm button (default), success state, or error state with guidance. PublishersDialog collects email and triggers verification flow. Two-step design prevents token consumption by email prefetching scanners.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end email verification flow</name>
  <files>n/a (verification only)</files>
  <action>
    Human verifies the complete email verification flow built in Tasks 1-2.

    What was built: Complete email verification flow — Book dialog form submission, verification email sent via Resend, two-step confirmation page, email verified in database.

    How to verify:
    1. Start dev server: `npm run dev`
    2. Navigate to the site, open Publishers Book dialog from the header Book dropdown
    3. Enter name and email, submit the form
    4. Verify "Check your email" confirmation appears in dialog
    5. Check Resend dashboard (resend.com/emails) for sent verification email
    6. Open the verification email — confirm it has branded layout with personalized greeting, purple CTA button, and 24h expiry notice
    7. Click the verification link in the email
    8. Confirm you land on the Continua verification page (not a direct download)
    9. Verify the page shows "Confirm Your Email" heading with a "Verify Email" button
    10. Click the "Verify Email" button
    11. Confirm you see "Email Verified!" success message
    12. Check Supabase table: contacts row should have email_verified=true, verification_token=NULL
    13. Try visiting the same verification link again — should see "invalid or already used" error

    Resume signal: Type "approved" or describe issues found
  </action>
  <verify>User confirms all 13 verification steps pass</verify>
  <done>End-to-end email verification flow works: dialog submission, branded email delivery, two-step confirmation page, database verification state, and used-token rejection</done>
</task>

</tasks>

<verification>
1. User can enter email in Publishers Book dialog and receive verification email
2. Verification email has branded template with name, CTA button, and expiry notice
3. Clicking email link shows confirmation page (not direct verification)
4. Clicking Verify button completes verification and shows success
5. Expired tokens show clear error with re-request guidance
6. Invalid token URLs show format error
7. Used tokens (already verified) show "already used" error
8. `npm run build` passes with all routes
</verification>

<success_criteria>
- End-to-end flow works: Book dialog → email → verification page → confirmed
- Two-step verification prevents token consumption by prefetching
- Expired tokens show user-friendly error with guidance
- Invalid tokens show error message
- Token cleared from database after successful verification
- email_verified set to true after successful verification
- Build passes, existing routes unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/07-email-verification-flow/07-02-SUMMARY.md`
</output>
